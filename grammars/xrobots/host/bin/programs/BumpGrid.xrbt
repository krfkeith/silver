Behavior root{
Behavior straight(int grid[4,4] , int x, int y, int facing,
					pBehavior nextMove(int g[4, 4], int i, int j, int f)){
   Entry{
        SetRSpeed{200.0}
        SetLSpeed{200.0}
   }
        Under Condition LeftBump || RightBump
               Apply Behavior backup(t::clock, grid::grid, 
														x::x, y::y, facing::facing,
														nextMove::probabilisticMove) 
        Under Condition clock > 1.0 	
		Apply Behavior nextMove(grid::grid, x::x, y::y, facing::facing)
   

   Exit{
        if (LeftBump || RightBump) then {
               if (facing == 0) then {
                  grid[x+1, y] := (100 - grid[x, y])/2;
						x:=x;
						y:=y;
					}
			 // check this formula with the c or lustre code      
               else if (facing == 1)then {
                  grid[x, y+1] := (100 - grid[x, y])/2; 
						x:=x;
						y:=y;
					}
              else if (facing ==2) then {
                  grid[x-1, y] := (100 - grid[x, y])/2;
						x:=x;
						y:=y;
					}
               else {
                  grid[x, y-1] := (100 - grid[x, y])/2 ;   		
						x:=x;
						y:=y;
					}
        } else { 
               if (facing == 0)then{
                  grid[x+1, y] := 0;
	 	 				 x := x + 1;
						y:=y;
					}
               else if (facing == 1)then{
                  grid[x, y+1] := 0;
						x:=x;
	          		y := y + 1;
				  }				 
              else if (facing == 2)then{
                  grid[x-1, y] := 0;
		  				x := x - 1;	
						y:=y;
					}	
               else {
                  grid[x, y-1] := 0;
						x:=x;
		  				y := y - 1;
					}	
   		}    
	}
}
Behavior turnRight( int grid[4,4], 	int x, int y, int facing,
					pBehavior nextMove(int g[4,4], int i, int j, int f)){
   Entry{
      clock := 0.0;
      SetRSpeed{250.0}
       SetLSpeed{25.0}
   }
        Under Condition clock > 2.2
		Apply Behavior nextMove(grid::grid, x::x, y::y, facing::facing)


    Exit{
      if (facing == 0)then{
         facing := 1;
	}
      else if (facing == 1)then{
         facing := 2;
	}
      else if (facing == 2)then{
         facing := 3;
	}
      else {
         facing :=0 ;
	}     
   }
}

Behavior turnLeft( int grid[4,4], int x, int y, int facing, 
					pBehavior nextMove(int g[4,4], int i, int j, int f)){
   Entry{
      clock := 0.0;
         SetRSpeed{25.0}
         SetLSpeed{250.0}
   }

        Under Condition clock > 2.2 
			Apply Behavior nextMove(grid::grid, x::x, y::y, facing::facing)

   Exit{
      if (facing == 0)then{
         facing := 3;
	}
      else if (facing == 1)then{
         facing := 0;
	}
      else if (facing == 2)then{
         facing := 1;
	}
      else {
         facing := 2  ;
	}   
   }
}

Behavior backup(float t, int grid[4,4] , int x, int y, int facing,
					pBehavior nextMove(int g[4, 4], int i, int j, int f)){
   Entry{
      clock := 0.0;
         SetRSpeed{-200.0}
         SetLSpeed{-200.0}
   }
        Under Condition clock > t 
			Apply Behavior nextMove(grid::grid, x::x, y::y, facing::facing)
     
}

Behavior stop(boolean bi, boolean bj, boolean bk, int  grid[4,4], 
					int x, int y, int facing,
					pBehavior nextMove(int g[4,4] , int i, int j, int f)){
  Entry{ 
        SetRSpeed{0.0}
        SetLSpeed{0.0}
   }

          Under Condition bi
                Apply Behavior straight(grid::grid, x::x, y::y,
														 facing::facing, 
															nextMove::nextMove)
          Under Condition bj
                Apply Behavior turnRight(grid::grid, x::x, y::y,
														 facing::facing, 
															nextMove::nextMove)
          Under Condition bk
                Apply Behavior turnLeft(grid::grid, x::x, y::y,
														 facing::facing, 
															nextMove::nextMove)   
}

//Behavior TurnAround{
 //  Entry{   
      //   SetRSpeed{250.0}
    //     SetLSpeed{25.0}
  // }
//
  //      Under Condition clock > 2.2 exit
 //  }
//}

Initial Behavior initGrid{
			int x;
			int y;
			int facing;
			int grid[4,4];

        // this is very rough syntax
        // I am just trying to create a function
        // to initialize the internal data
       Entry{
       // for all i, j
         //   grid[i,j] = 50;
		x := 1;
		y := 1;
		facing := 0;
       } 
       	Under Condition true
          Apply Behavior probabilisticMove(grid::grid, x::x, y::y, facing::facing)
      
}

Behavior probabilisticMove(int grid[4,4], int x, int y, int facing){     
    float r;      
	Entry{
	    r := (rand() + 50.0)/450.0;
                    
         }

        
        Under Condition (((((facing == 0 
                          && (grid[x+1, y] < 50 || grid[x+1, y] == 0) )
                          && ((grid[x, y+1] < 50 || grid[x, y+1] == 0) 
                          && (grid[x, y-1] < 50 || grid[x, y-1] == 0)))
                          || ((facing == 2  
                          && (grid[x-1, y] < 50 || grid[x-1, y] == 0) )
                          && ((grid[x, y+1] < 50 || grid[x, y+1] == 0)
                          && (grid[x, y-1] < 50 || grid[x, y-1] == 0) )))
                          || ((facing == 1  
                          && (grid[x, y+1] < 50 || grid[x, y+1] == 0))
                          && ((grid[x+1, y] < 50 || grid[x, y+1] == 0)
                          && (grid[x-1, y] < 50 || grid[x-1, y] == 0))))   
                          ||  ((facing == 3  
                          && (grid[x, y-1] < 50 || grid[x, y-1] == 0))
                          && ((grid[x+1, y] < 50 || grid[x+1, y] == 0)
                          && (grid[x-1, y] < 50 || grid[x-1, y] == 0))))
              Apply Behavior stop(bi::r<0.5, 
					 						 bj::r>0.5 && r<0.75, 												 bk::r>0.75, 
											 grid::grid, x::x, 
											 y::y,
											 facing::facing,
											 nextMove:: deterministicMove)        				Under Condition true
               Apply Behavior stop(bi::r<0.5, 
					 						 bj::r>0.5 && r<0.75, 												 bk::r>0.75, 
											 grid::grid, x::x, 
											 y::y,
											 facing::facing,
											 nextMove:: probabilisticMove)    
        
}

Behavior deterministicMove(int grid[4,4], int x, int y, int facing){     
              Under Condition ((facing == 0
                                    && grid[x+1, y] < 50) 
                                    && (grid[x, y+1] < 50
                                    && grid[x, y-1] < 50))
               Apply Behavior stop(bi::grid[x+1,y]<50, 
                                 bj:: grid[x+1,y]>0.5 && grid[x, y-1]<50, 
                   bk::(grid[x+1,y]>0.5 && grid[x, y-1]>50) && grid[x, y+1],
                                         grid::grid, x::x, y::y,
														facing::facing,
														nextMove::deterministicMove)  
            UnderCondition  ((facing == 1  
                                    && grid[x, y+1] < 50 )
                                    && (grid[x+1, y] < 50
                                    && grid[x-1, y] < 50)   )
                    Apply Behavior stop(bi::grid[x,y+1]<50, 
                               bj::grid[x,y+1]>0.5 && grid[x-1, y]<50, 
                 bk::(grid[x,y+1]>0.5 && grid[x-1, y]>50) && grid[x+1, y], 
                                 grid::grid, x::x, y::y,
												facing::facing,
												nextMove::deterministicMove) 
                  Under Condition ((facing == 2  
                                    && grid[x-1, y] < 50 )
                                    && (grid[x, y+1] < 50
                                    && grid[x, y-1] < 50)   )
                 Apply Behavior stop(bi::grid[x-1,y]<50, 
                                 bj::grid[x-1,y]>0.5 && grid[x, y-1]<50, 
                   bk::(grid[x-1,y]>0.5 && grid[x, y-1]>50) && grid[x, y+1], 
                                         grid::grid, x::x, y::y,
														facing::facing,
														nextMove::deterministicMove)   
                  Under Condition((facing == 3
						   && grid[x, y-1] < 50 )
                         && (grid[x+1, y] < 50
                        && grid[x-1, y] < 50))
                    Apply Behavior stop(bi::grid[x,y-1]<50, 
                         bj::grid[x,y-1]>0.5 && grid[x-1, y]<50, 
                  bk::(grid[x,y-1]>0.5 && grid[x-1, y]>50) && grid[x+1, y], 
                                         grid::grid, x::x, y::y,
														facing::facing,
														nextMove::deterministicMove) 
					Under Condition true       
              Apply Behavior probabilisticMove(grid::grid, x::x, y::y,
																facing::facing)    
       
}
}	
