----------------------------------------------------------------------
A simple arithmetic expression language.
----------------------------------------------------------------------
1. Consider the Silver specification for "dc".

- The concrete syntax in Expr.sv ensures that operator precedence and
  associativity is ensured.

2. A higher order attribute, ast_Expr, is used to compute a tree using
the abstract productions.  On this, we compute the value of the
expression since the grammar is simpler.

3. In BetterPP.sv we see the use of inherited attributes.  These are
passed down the tree and used to determine when parenthesis need to be
used.

----------------------------------------------------------------------
A simple imperative language and language extensions specified using
Silver and Copper.
----------------------------------------------------------------------
1. Consider the Silver specification for "simple"

- Consider some sample programs in simple/host/demos.  This is a
  simple imperative language with only primitive types.  Some in
  host/bin, others in composed directories.

- Examine the directory structure in simple to see how the files 
  are organized.

   simple
     terminals
       Terminals.sv
     concretesyntax
       Root_c.sv, Stmt_c.sv, Decl_c.sv, Expr_c.sv, For_c.sv
     abstractsyntax
       Root.sv, Stmt.sv, Decl.sv, Expr.sv, For.sv
       Env.sv, TypeChecking.sv, C-trans.sv
     host
       Main.sv
       bin
         Main.sv, silver-compile
         1.simple,  2.simple
       driver
         Driver.sv
     extensions
       repeat_until
         RepeatUntil.sv
       implication
         Implication.sv
     composed
       simple_repeat_until
         Main.sv, silver-compile, repeat.simple      
       simple_implication
         Main.sv, silver-compile, implies.simple      
       simple_all
         Main.sv, silver-compile, all.simple      


2. Concrete syntax and operator precedence and associativity.
- Look at Expr_c.sv.  The grammar here is ambiguous.
- Compare to dc/Expr.sv
- Examine specifications in Terminals.sv

- Task. Add boolean operators &&, ||, !.
  - modify Terminals.sv and Expr_c.sv
  - ensure that Driver.sv only prints concrete syntax


3. Abstract syntax.
- Briefly look at Expr.sv.  Computing pp, errors, etc.
- See the abstract productions for and, or, not in Expr.sv.
- Task. Use these in your concrete productions.
- Modify Driver.sv to print abstract syntax tree as well.  Just
  uncomment the appropriate lines.

- Look at Stmt_c.sv.  The grammar here is not ambiguous and relies on
  extra nonterminals to remove the "dangling-else" ambiguity.

  We don't want to define our attributes on these messy productions.
  The ones in Stmt.sv are much cleaner.


4. Semantic analysis.
- This includes checking that variables are defined and that
  expressions are used in a type-safe way.

- Look at the use of Env<a> to see how names are bound to their
  declaration in the abstract syntax.

  We see "reference attributes" and values in the "Decorated TypeExpr"
  attribute and in the environment.
 
  In varRef, we see how this is used.  And we see the use of
  "collection attributes".

- Task. Complete semantic analysis on boolean operator abstract
  productions.  Write a program that demonstrates that you catch the
  use of undeclared variables inside a boolean expression.

- Task. Complete name analysis on assignment statements.  Write a
  simple program that demonstrates that you detect and report the use
  of an undeclared variable on the left hand side of an assignment.


5. Type checking.
- Examine TypeChecking.sv
- Collection attributes are used to add more errors.
- Together, let's add type checking on the while-loop.
- Task. Complete type checking on boolean operators.
- Uncomment lines in Driver.sv to display errors.
- Write a program that demonstrates that you catch type errors on
  boolean operators.


6. Forwarding:
- examine the relational operators in Expr.sv
- Task.  Use forwarding on the "or" boolean operator.  Apply De
  Morgan's Law. 
- Look at For.sv (and For_c.sv) to see another use of forwarding.


7. Translation to C, using more aspect productions.
- Examine C-trans.sv.   Notice that some productions are missing!  The
  ones that forward to something else are not here.
- The C translation is exceedingly simple here.
- Modify Driver.sv to generate C code.


8. Language extensions
- Consider the implication extension.
- Add a repeat-until loop as a language extension.
  ++ provide dir structure and sample program


9. Additional tasks.
- Add type checking on assignment statement.

- What happens when a non-integer expression is used in one of the
  bounds of a for-loop?  How useful are the error messages?  They can
  probably be improved by doing error checking on the for-loop instead
  of getting the errors attribute from the forwarded to construct.
  Define errors and other needed supporting attributes to do this.

- Add a for loop that declares its index variable.
  "for (Integer i = 1 to 10) { ... }"

- Add a character data type.  Where must this be done?  What files
  need to be modified?

- Error messages not on undeclared variables do not have line
  numbers.  Add "ln" and "cl" synthesized attributes on abstract
  nonterminals to keep track of the location of expressions and
  statements.   Note that "line" and "column" attributes on terminals
  are built-ins and can only be used on terminals, and cannot be added
  to nonterminals.
